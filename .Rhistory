dept_vertex_colors[dept_vertex_colors == 0] = colors[1]
dept_vertex_colors[dept_vertex_colors == 1] = colors[2]
dept_vertex_colors[dept_vertex_colors == 2] = colors[3]
dept_vertex_colors[dept_vertex_colors == 3] = colors[4]
dept_vertex_colors[dept_vertex_colors == 4] = colors[5]
plot(krack_reports_to_only,
vertex.color=dept_vertex_colors,
vertex.label=NA,
edge.arrow.size=.5)
dev.off()
dept_vertex_colors = igraph::get.vertex.attribute(krack_full,"DEPT")
colors = c('Black', 'Red', 'Blue', 'Yellow', 'Green')
dept_vertex_colors[dept_vertex_colors == 0] = colors[1]
dept_vertex_colors[dept_vertex_colors == 1] = colors[2]
dept_vertex_colors[dept_vertex_colors == 2] = colors[3]
dept_vertex_colors[dept_vertex_colors == 3] = colors[4]
dept_vertex_colors[dept_vertex_colors == 4] = colors[5]
plot(krack_reports_to_only,
vertex.color=dept_vertex_colors,
vertex.label=NA,
edge.arrow.size=.5)
dev.off()
tenure_vertex_sizes = igraph::get.vertex.attribute(krack_full,"TENURE")
plot(krack_reports_to_only,
vertex.color=dept_vertex_colors,
vertex.label=NA,
edge.arrow.size=.5,
vertex.size=tenure_vertex_sizes)
dev.off()
tie_type_colors = c(rgb(1,0,0,.5), rgb(0,0,1,.5), rgb(0,0,0,.5))
E(krack_full)$color[ E(krack_full)$advice_tie==1 ] = tie_type_colors[1]
E(krack_full)$color[ E(krack_full)$friendship_tie==1 ] = tie_type_colors[2]
E(krack_full)$color[ E(krack_full)$reports_to_tie==1 ] = tie_type_colors[3]
E(krack_full)$arrow.size=.5
V(krack_full)$color = dept_vertex_colors
V(krack_full)$frame = dept_vertex_colors
plot(krack_full,
vertex.color=dept_vertex_colors,
vertex.label=NA,
edge.arrow.size=.5,
vertex.size=tenure_vertex_sizes)
# Add a legend. Note that the plot window must be open for this to
# work.
legend(1,
1.25,
legend = c('Advice',
'Friendship',
'Reports To'),
col = tie_type_colors,
lty=1,
cex = .7)
dev.off()
Net.krack_reports_to <- asNetwork(krack_reports_to_only)
Net.krack_friendship <- asNetwork(krack_friendship_only)
Net.krack_advice <- asNetwork(krack_advice_only)
Net.krack_full <- asNetwork(krack_full)
adjacency.krack_reports_to_only <- get.adjacency(krack_reports_to_only)
adjacency.krack_friendship_only <- get.adjacency(krack_friendship_only)
adjacency.krack_advice_only <- get.adjacency(krack_advice_only)
adjacency.krack_full <- get.adjacency(krack_full)
g.krack_reports_to <- graph_from_adjacency_matrix(adjacency.krack_reports_to_only)
g.krack_friendship <- graph_from_adjacency_matrix(adjacency.krack_friendship_only)
g.krack_advice <- graph_from_adjacency_matrix(adjacency.krack_advice_only)
g.krack_full <- graph_from_adjacency_matrix(adjacency.krack_full)
incidence.krack_reports_to <- as.matrix(Net.krack_reports_to, matrix.type="incidence")
incidence.krack_friendship <- as.matrix(Net.krack_friendship, matrix.type="incidence")
incidence.krack_advice <- as.matrix(Net.krack_advice, matrix.type="incidence")
incidence.krack_full <- as.matrix(Net.krack_full, matrix.type="incidence")
g.krack_reports_to <- graph_from_incidence_matrix(incidence.krack_reports_to)
g.krack_friendship <- graph_from_incidence_matrix(incidence.krack_friendship)
g.krack_advice <- graph_from_incidence_matrix(incidence.krack_advice)
g.krack_full <- graph_from_incidence_matrix(incidence.krack_full)
g <- make_lattice(length = 5, dim = 2)
plot(g)
g <- make_full_graph(10)
plot(g)
g <- make_empty_graph(n = 10)
plot(g)
g <- make_ring(10)
plot(g)
g <- make_star(10, mode = "out")
plot(g)
g <- make_tree(10, 3, mode = "undirected")
plot(g)
g <- sample_gnp(10, 1/10)
plot(g)
g <- sample_pa(100)
write.graph(krack_full, file='krack_full.dl', format="pajek")
write.graph(krack_full, file='krack_full.txt', format="edgelist")
## A graph with two separateD trees
g <- make_tree(10) %du% make_tree(10)
plot(g)
plot(g)
dfs(g, root=1, "out", TRUE, TRUE, TRUE, TRUE)
## A graph with two separateD rings
g <- make_tree(10) %du% make_tree(10)
plot(g)
dfs(g, root=1, "out", TRUE, TRUE, TRUE, TRUE)
bfs(g, root=1, "out", order=TRUE, rank=TRUE, father=TRUE, pred=TRUE, succ=TRUE, dist=TRUE)
bfs(g, root=1, "out", order=TRUE, rank=TRUE, father=TRUE, pred=TRUE, succ=TRUE, dist=TRUE)
shortest_paths(krack_reports_to_only, from= 1, to = 5, mode = "out")
shortest_paths(krack_advice_only, from= 1, to = 5, mode = "out")
shortest_paths(krack_full, from= 1, to = 5, mode = "out")
shortest_paths(krack_friendship_only, from= 1, to = 5, mode = "out")
induced_subgraph(krack_reports_to_only, 1:7)
induced_subgraph(krack_reports_to_only, 1:7)
induced_subgraph(krack_friendship_only, 1:7)
induced_subgraph(krack_advice_only, 1:7)
g <- sample_gnp(10, 0.3)
induced_subgraph(krack_full, 1:7)
clique_num(g)
cliques(g, min=6)
largest_cliques(g)
max_cliques(g)
g <- sample_gnp(10, 1/10)
components <- decompose(g, min.vertices=2)
components
length(components)
sapply(components, diameter)
sapply(components, gorder)
get.largest.component <- function(g)
{
X <- get.adjacency(g)
N <- gorder(g)
CompSize <- 0
Comp1 <- NULL
for(i in 1:N){
# A breadh-first search is conducted starting from vertex v.
C <- subcomponent(g, i)
if(length(C) > CompSize)
{
CompSize <- length(C)
Comp1 <- C
}
}
return(induced_subgraph(g, Comp1))
}
gorder(get.largest.component(g))
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Can you replace the function subcomponent() by building your own function?
#----------------------------------------------------------------------------------
# Can you replace the function subcomponent() by building your own function?
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Can you replace the function subcomponent() by building your own function?
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Can you replace the function subcomponent() by building your own function?
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Can you replace the function subcomponent() by building your own function?
#----------------------------------------------------------------------------------
adjacency.krack_friendship_only
rowsum(adjacency.krack_friendship_only)
rowsum((adjacency.krack_friendship_only))
View(adjacency.krack_advice_only)
rowsum(as.data.frame((adjacency.krack_friendship_only)))
rowsum(data.frame((adjacency.krack_friendship_only)))
adjacency.krack_friendship_only
rowSums((adjacency.krack_friendship_only))
rowSums(adjacency.krack_friendship_only)
class((adjacency.krack_friendship_only))
rowSums(as.matrix(adjacency.krack_friendship_only))
d_in<-colSums(as.matrix(adjacency.krack_friendship_only))
d_out<-rowSums(as.matrix(adjacency.krack_friendship_only))
attributes$TENURE
md = lm(d_out ~ attributes$TENURE)
summary(md)
names(attributes)
md = lm(d_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md)
md = lm(d_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md)
### run lm on friendship
d_fr_in<-colSums(as.matrix(adjacency.krack_friendship_only))
d_fr_out<-rowSums(as.matrix(adjacency.krack_friendship_only))
md = lm(d_fr_out ~ attributes$TENURE)
summary(md)
md = lm(d_fr_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md)
md = lm(d_fr_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md)
md_fr = lm(d_fr_out ~ attributes$TENURE)
summary(md_fr)
md_fr = lm(d_fr_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_fr)
summary(md_fr)
md_fr = lm(d_fr_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
###
adjacency.krack_advice_only <- get.adjacency(krack_advice_only)
### run lm on advice
d_ad_in<-colSums(as.matrix(adjacency.krack_advice_only))
d_ad_out<-rowSums(as.matrix(adjacency.krack_advice_only))
md_ad = lm(d_fr_out ~ attributes$TENURE)
summary(md_ad)
md_ad = lm(d_fr_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
md_ad = lm(d_fr_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
md_ad = lm(d_ad_out ~ attributes$TENURE)
summary(md_ad)
md_ad = lm(d_ad_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
md_ad = lm(d_ad_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
md_ad = lm(d_ad_out ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
md_ad = lm(d_ad_in ~ attributes$TENURE+attributes$AGE+attributes$LEVEL+as.factor(attributes$DEPT))
summary(md_ad)
View(incidence.krack_advice)
incidence.krack_reports_to <- as.matrix(Net.krack_reports_to, matrix.type="incidence")
incidence.krack_friendship <- as.matrix(Net.krack_friendship, matrix.type="incidence")
incidence.krack_advice <- as.matrix(Net.krack_advice, matrix.type="incidence")
incidence.krack_full <- as.matrix(Net.krack_full, matrix.type="incidence")
g.krack_reports_to <- graph_from_incidence_matrix(incidence.krack_reports_to)
g.krack_advice <- graph_from_incidence_matrix(incidence.krack_advice)
g.krack_friendship <- graph_from_incidence_matrix(incidence.krack_friendship)
g.krack_full <- graph_from_incidence_matrix(incidence.krack_full)
write.graph(krack_full, file='krack_full.dl', format="pajek")
write.graph(krack_full, file='krack_full.txt', format="edgelist")
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
## view the first few rows of the data
head(mydata)
hist(mydata$gre)
hist(mydata$gpa)
hist(mydata$rank)
set.seed(1)
train_data <- mydata[sample(nrow(mydata), 300), ]
# test_data<-mydata[-sample(nrow(mydata), 300), ]
X_train <-as.matrix(train_data[2:4])
X<-X_train
# X_train <- scale(features)
y <- as.matrix(train_data[1])
theta <- rep(0.1,ncol(features))
lr <- 0.01
iters <- 1000
sigmoid <- function(z){
return(1/(1+exp(-z)))
}
z = X%*%theta
h = sigmoid(z)
###################################
loss <- function(h, y){
return(mean(-y*log(h) - (1 - y)*log(1 - h)))
}
###################################
gradient <- function(X, h, y){
return(t(X)%*%(h-y)/nrow(y))
}
#################################
#Cost Function
cost <- function(theta){
m <- nrow(X)
h <- sigmoid(X%*%theta)
J <- (1/m)*sum((-y*log(h)) - ((1-y)*log(1-h)))
return(J)
}
gradient <- function(X, h, y){
grad <- t(X)%*%(h-y)/nrow(y)
return(grad)
}
#Intial theta
initial_theta <- rep(0.01,ncol(X))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
initial_theta <- rep(0.01,ncol(X))
initial_theta
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
## view the first few rows of the data
head(mydata)
hist(mydata$gre)
hist(mydata$gpa)
hist(mydata$rank)
set.seed(1)
train_data <- mydata[sample(nrow(mydata), 300), ]
# test_data<-mydata[-sample(nrow(mydata), 300), ]
X_train <-as.matrix(train_data[2:4])
X<-X_train
# X_train <- scale(features)
y <- as.matrix(train_data[1])
theta <- rep(0.1,ncol(features))
lr <- 0.01
iters <- 1000
sigmoid <- function(z){
return(1/(1+exp(-z)))
}
z = X%*%theta
h = sigmoid(z)
###################################
loss <- function(h, y){
return(mean(-y*log(h) - (1 - y)*log(1 - h)))
}
###################################
gradient <- function(X, h, y){
return(t(X)%*%(h-y)/nrow(y))
}
#################################
#Cost Function
cost <- function(theta){
m <- nrow(X)
h <- sigmoid(X%*%theta)
J <- (1/m)*sum((-y*log(h)) - ((1-y)*log(1-h)))
return(J)
}
gradient <- function(X, h, y){
grad <- t(X)%*%(h-y)/nrow(y)
return(grad)
}
#Intial theta
initial_theta <- rep(0.01,ncol(X))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
head(mydata)
initial_theta <- rep(0.01,ncol(X)+1)
initial_theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
initial_theta <- rep(0.01,ncol(X))
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
gradient(initial_theta)
gradient <- function(theta){
h <- sigmoid(X%*%theta)
grad <- t(X)%*%(h-y)/nrow(y)
return(grad)
}
J <- (1/m)*sum((-y*log(h)) - ((1-y)*log(1-h)))
return(J)
#################################
#Cost Function
cost <- function(theta){
m <- nrow(X)
h <- sigmoid(X%*%theta)
J <- (1/m)*sum((-y*log(h)) - ((1-y)*log(1-h)))
return(J)
}
gradient <- function(theta){
h <- sigmoid(X%*%theta)
grad <- t(X)%*%(h-y)/nrow(y)
return(grad)
}
#Intial theta
initial_theta <- rep(0.01,ncol(X))
#Cost at inital theta
cost(initial_theta)
gradient(initial_theta)
gradient(initial_theta)
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
theta_optim
#set theta
theta <- theta_optim$par
theta
gradient(initial_theta)
theta_optim <- optim(par=initial_theta,fn=cost,gr=gradient)
theta_optim
# set working directory
wd = "C:/Users/eviriyakovithya/Documents/GitHub/Portfolio-Optimization/"
setwd(wd)
getwd()
# read in data
if (!require("utf8")) install.packages("utf8");library(utf8)
if (!require("readr")) install.packages("readr");library(readr)
df <- read.csv("C:/Users/eviriyakovithya/Documents/GitHub/Portfolio-Optimization/Processed_Data/_combined_csv.csv")
if (!require("tidyverse")) install.packages("tidyverse");library(tidyverse)
if (!require("dplyr")) install.packages("dplyr");library(dplyr)
if (!require("lubridate")) install.packages("lubridate");library(lubridate)
df<-data.frame(df)
# rename column
names(df)[1]<-"date"
# change to date time type
df$date <- ymd(df$date)
# aggregate monthly, group by mean
df_month500<- df %>% group_by(month=floor_date(date, "month")) %>% summarise_each(funs(mean))
# sample only 300 columns (due to AMPL student version limitation)
df_month<- df_month500[, sample(ncol(df_month500[3:length(df_month500)]), 300)]
# define function for gain/loss percentages between each month
pct_chg <- function(x){
pct_change <- -(x-lead(x))/x # Gets percent change in profit from preceding year
return(pct_change)
}
# # test the function
# x = df_month$ABB[1:10]
# ahead = df_month(x)
# pct_chg(x)
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
CovMat<- cov(RetMat)
write.csv(CovMat,'CovMat.csv')
# calculate mean of % changes (ExpRet: Expected Return)
ExpRet <- colMeans(RetMat, na.rm = TRUE)
write.csv(ExpRet,'ExpRet.csv')
# set working directory
wd = "C:/Users/eviriyakovithya/Documents/GitHub/Portfolio-Optimization/"
setwd(wd)
getwd()
# read in data
if (!require("utf8")) install.packages("utf8");library(utf8)
if (!require("readr")) install.packages("readr");library(readr)
df <- read.csv("C:/Users/eviriyakovithya/Documents/GitHub/Portfolio-Optimization/Processed_Data/_combined_csv.csv")
if (!require("tidyverse")) install.packages("tidyverse");library(tidyverse)
if (!require("dplyr")) install.packages("dplyr");library(dplyr)
if (!require("lubridate")) install.packages("lubridate");library(lubridate)
df<-data.frame(df)
# rename column
names(df)[1]<-"date"
# change to date time type
df$date <- ymd(df$date)
# aggregate monthly, group by mean
df_month500<- df %>% group_by(month=floor_date(date, "month")) %>% summarise_each(funs(mean))
# sample only 300 columns (due to AMPL student version limitation)
df_month<- df_month500[, sample(ncol(df_month500[3:length(df_month500)]), 300)]
# define function for gain/loss percentages between each month
pct_chg <- function(x){
pct_change <- -(x-lead(x))/x # Gets percent change in profit from preceding year
return(pct_change)
}
# # test the function
# x = df_month$ABB[1:10]
# ahead = df_month(x)
# pct_chg(x)
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
CovMat<- cov(RetMat)
write.csv(CovMat,'CovMat.csv')
# calculate mean of % changes (ExpRet: Expected Return)
ExpRet <- colMeans(RetMat, na.rm = TRUE)
write.csv(ExpRet,'ExpRet.csv')
# calculate standard deviation of % changes (Stdv)
Stdv <- apply(RetMat, 2, sd, na.rm = TRUE)
write.csv(Stdv,'Stdv.csv')
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
CovMat<- cov(RetMat)
write.csv(CovMat,'CovMat.csv')
ovMat<- cov(RetMat)
View(RetMat)
CovMat<- cov(RetMat)
set.seed(123)
# aggregate monthly, group by mean
df_month500<- df %>% group_by(month=floor_date(date, "month")) %>% summarise_each(funs(mean))
# sample only 300 columns (due to AMPL student version limitation)
df_month<- df_month500[, sample(ncol(df_month500[3:length(df_month500)]), 300)]
# define function for gain/loss percentages between each month
pct_chg <- function(x){
pct_change <- -(x-lead(x))/x # Gets percent change in profit from preceding year
return(pct_change)
}
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
View(RetMat)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
CovMat<- cov(RetMat)
head(CovMat)
head(RetMat)
CovMat<- cov(as.matrix(RetMat))
str(RetMat)
df<-data.frame(df)
# rename column
names(df)[1]<-"date"
# change to date time type
df$date <- ymd(df$date)
set.seed(123)
# aggregate monthly, group by mean
df_month500<- df %>% group_by(month=floor_date(date, "month")) %>% summarise_each(funs(mean))
names(df_month500)
df_month<- df_month500[, sample(ncol(df_month500[3:length(df_month500)]), 300)]
names(df_month)
pct_chg <- function(x){
pct_change <- -(x-lead(x))/x # Gets percent change in profit from preceding year
return(pct_change)
}
df_pct <- data.frame(lapply(df_month, pct_chg))
names(df_pct)
str(df_pct)
# sample only 300 columns (due to AMPL student version limitation)
df_month500<-df_month500[3:length(df_month500)]
set.seed(123)
df_month<- df_month500[, sample(ncol(df_month500[1:length(df_month500)]), 300)]
# define function for gain/loss percentages between each month
pct_chg <- function(x){
pct_change <- -(x-lead(x))/x # Gets percent change in profit from preceding year
return(pct_change)
}
# apply to the dataframe, remove NAs (last row), (RetMat: Return Matrix)
df_pct <- data.frame(lapply(df_month, pct_chg))
RetMat <- na.omit(df_pct)
write.csv(RetMat,'RetMat.csv')
CovMat<- cov(as.matrix(RetMat))
write.csv(CovMat,'CovMat.csv')
# calculate mean of % changes (ExpRet: Expected Return)
ExpRet <- colMeans(RetMat, na.rm = TRUE)
write.csv(ExpRet,'ExpRet.csv')
# calculate standard deviation of % changes (Stdv)
Stdv <- apply(RetMat, 2, sd, na.rm = TRUE)
write.csv(Stdv,'Stdv.csv')
